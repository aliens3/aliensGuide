---
layout: layouts/post.njk
---


## インターフェース

この[ゲーム](/guide/computer/game.html)をやる．

オリジナルの[PONG(youtube動画)](https://www.youtube.com/watch?v=fiShX2pTz9A)をイメージして作った．
これと比べると，相手が壁になっているし，点数表示もないし，効果音もない．mPONG(minimum PONG)と呼ぼう．

mPONGはゲームとしては面白くないが，このゲームを0から作ることを通してコンピュータの基本の全てを学ぶことができる．


## ボールの最初の動き

まずはmPONGはボールもバットも動いている．動きを表す(動画を作る，アニメーションを作る)ための一般的な方法はパラパラ漫画と同じで，連続した画像を素早く見せることだ．

![ボール，バットと赤字で書いた画像]()

<iframe width="560" height="315" src="https://www.youtube.com/embed/ryGv8wXz_UA" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>

mPONGでは最初に左上からボールが落ちてくるが，これを実現する方法は，
1. 現在のボールを消す
2. 次の位置にボールを書く
の繰り返しだ．1のステップは前の画像を消すこと，2のステップで次の画像を見せることに対応して，これを一定以上の速さで行うと，ボールは動いているように見える．

![iframeでの埋め込み．ボールの1ステップごとと，自動進み]()

これをコンピュータで実現するためには，どうすればいいか．
まず，ゲーム画面は 512(W) * 256(H)ピクセルからなる．ピクセルというのは異なる色を塗れる最小の単位だ．
例えば2(W) * 2(H)ピクセルからなる画面を白と黒の2色で塗ろうと思えば，左上の1ピクセルは白か黒かで塗れ，右上のピクセルも白か黒かで塗れ，と考えていくと，合計2^4=16通りの塗り方があることが分かる．白で塗ることを0，黒で塗ることを1で表すことにしよう．

![画像 16通りのうち幾つか 01にして1列にした数字も]()

mPONGでも同様に色は白と黒の二色しか使わない．そこで同じようにしてゲームのある瞬間における画面の状態は，512 * 256のマスに配置された01の状態と対応することが分かる．また，ボールは実は2*2ピクセルの黒で構成されている．

![画像　ボールを赤線でピクセルごとに分割]()

そうすると，

1. 現在のボールを消す
2. 次の位置にボールを書く

というステップは，

1. 現在のボールの位置に対応する4つの1を0に変える．
2. 次の位置に対応する4つの0を1に変える．

![画像　拡大した01の書き換え]()

という数字の書き換えに対応することが分かる．

## バットの動き

次にバットの動きについて．バットの動きも，現在の位置を0に変えて，次の位置を1に変えることを繰り返すのは同じだが，プレイヤーの入力によって，次の位置がどちらになるのかが決まる．プレイヤーが右矢印を押していた場合は右に動くし，左矢印を押していた場合は左に動く．

~~まずプレイヤーのキーボード入力はどう捉えればいいだろうか．各キーボードの各キーは押されているか，押されていないかのどちらかである．1ピクセルには白と黒の状態があるように，ここでも各キーの状態は0(押されている)か1(押されていない)を割り当てることができる．~~

~~ということは，ゲームのある瞬間におけるキーボードの状況は，やはり次のような01のマスに対応させることができる．~~

キーボードの状態はasciiの値と対応して16bitの値と対応できること．

mPONGゲームでコンピュータは，キーボードからの入力を受け，それに応じてゲームを進行させて，結果をスクリーンに出力し，出力の結果を受けてプレイヤーがキーボードに入力して，ということを繰り返して進行するわけだが，以上の考察から，ゲームのある瞬間における入出力の状態は01に置き換えられることが分かった．

![画像　入力と出力のループ]()

そこで，出力のためには，512\*256個の01があればよく，入力のためには仮に512個の01を用意するとしよう．合計512\*257個の01をただ横並びにするのは，分かりづらいので，16個の01を一つのまとまりにして，これを縦に並べることにする．一つ一つの01をビット(bit)とよぶことにすれば，これは16bitを一まとまりにすることに等しい．この一まとまりにした16bitをレジスタと呼ぶことにしよう．つまり入出力を表すためには，次のように 512*256/16 + 512/16個のレジスタがあればいい．このレジスタのまとまりをメモリと呼ぼう．

## ボールに戻って

ボールを動かすためには，

1. 現在のボールの位置に対応する4つの1を0に変える．
2. 次の位置に対応する4つの0を1に変える．

という2ステップが必要だった．

しかし，ゲームが進行すると，ボールは必ずしも右下へ移動するわけではない．
壁にぶつかるとボールの進む方向は変わるのだ．そして，次の位置がどこになるのかは，ボールが進む方向による．
ということは，2の次の位置を決定するためには，現在のボールの位置に加えて，ボールの方向という変数を記録しておく必要がある．
ボールの進む方向は4通りあるので，次のように2つの01があれば進む方向と対応させることができる．
つまり，2つの01もメモリに保存しておいて，この値に応じて，次の方向を決めればいいのだ．
例えば，メモリのある場所の1バイト分はこの情報を記録しておくバイトとすれば，このバイトの値を読んで，それに応じて次の位置を決めることができる．
こうしてメモリは，入出力だけでなく変数を記録しておく場所でもある．

ボールを動かす上では，現在のボールの位置もメモリに保存しておく変数だ．<marginnote>出力の8Kメモリのなかで1が4つあるところが，現在のボールの場所ではないかと思うかもしれないが，データに対応してスクリーンへの出力が行われるのであって，出力はデータの保存先ではない．言い換えれば，「ボールがどこどこにあって，バットがどこどこにある」というゲームの状態をもとに，スクリーンへ出力が決まるのだ．さらに言えば，むりにスクリーンからボールの位置を割り出そうとすれば，4つの1がある場所を8Kバイトの中から探すことになり，効率が悪い．データの保存先を決めておけば特定の位置の2つのレジスタの値(x,y)を見ればすむ．他にもいくつものダメなポイントを挙げることができるので考えてみよう．</marginnote>例えば，左上のピクセルの位置を(x,y)として保存すればいいだろう．このx,yの値から4つのピクセルの位置を求めるには，次のようにすればいい．

![左上のx,yから4つのピクセルの位置を求める]()

この現在のボールの位置と，進むべき方向から，次のボールの位置が計算される．これも1つ進めるために行うべきことをやってみよう．

![具体的に1つ進める]()

ここまで見ると分かる通り，ボールの位置を計算するためには，

1. メモリの読み書き
2. 四則演算
3. 条件分岐

が必要なことが分かる．バットの位置計算や，ボールの壁の跳ね返り，ゲームオーバーになるかどうかの判定も1,2,3ができればできることを確認しよう．

![3つの実行方法]()

## 3つの命令を01で表す A命令 C命令の導入

この3つの命令も01で表したい．

ボールを動かしたり，ボールを壁で跳ね返らせたりすることは，3つの命令を順次実行することで達成できた．
ここで，3種類の命令すべてが01で表せるとすれば，コンピュータへの指示(=プログラム)は，入出力や変数と同じく，16bitの連なりとなる．

実際にやってみよう．まず，メモリにアクセスするためにはメモリの番地を指定する必要がある．
これは，入出力や変数と同じく，メモリ内のどこかのレジスタに作ってもいいのだが，メモリにアクセスするためには，毎回このレジスタを参照する必要があるので，メモリとは独立させることにしよう．この16bitをAレジスタとよぶ．

例えばAレジスタが のとき， この情報をつかって，　にアクセスできる．

もう１つメモリから独立させてDレジスタというものを作る．これは計算を実行するためのレジスタだ．これもAレジスタと同様に，メモリ内のどこかに場所を確保してもいいのだが，

3種の命令は次の2種の16bitの01で表現できる．

A命令(adress命令) 0vvv vvvv vvvv vvvv 
これは，最上位のbitは0として，残りの15bitで，メモリのアドレスを表現する．

![](/img/memory.jpg)
![image コンピュータ1の図を参照]()

C命令(compute命令) 111a cccc ccdd djjj


## 簡単な表現

しかし，この16bitの連なりをそのまま書くのは，読みづらい(可読性が低い)ので，それぞれの命令に対応した自然言語的な表現を紹介する．

## いろいろなプログラム

これを使ってごくごく簡単なプログラムを書いてみよう．

## アセンブラで機械語になおす

しかしアセンブリ言語で書いたコードはそれ自体でCPUを動かすことはできない．これを機械語に変換する必要がある．
この変換器をアセンブラという．アセンブラをこの段階で書くことはできないが，基本的にはアセンブラの1行の命令は，ある1つの機械命令に対応しているので，
可読性のためにアセンブリ言語で書いているだけで，これを機械語にすることは人の手でもできることなので，なにか原理的に不可能なことをしているわけではない．

ちなみに，例えば普通のパソコンで，こういうアセンブリ言語でコードを書く時，それに対応する01のデータはどうなっているのだろうか．
例えば と打って保存するときには，01のデータにする必要があるが，そのためには各文字とそれに対応する数字を決めないといけない．

このようなデータは一般的にはテキストファイルと呼ばれ，文字コードを正しく指定することで正しく表示できる．
一方で，機械語には対応する文字が存在しないので，開こうとしても文字では表示できず01の羅列にしかならない．
ファイルという概念はOSが提供するものであり，これについてはコンピュータ3で詳しく見る．


## ブラックボックスとしてのコンピュータは何ができればいいか？

こうしてコンピュータがやるべきことが明らかになった．
コンピュータは

メモリ内のプログラムを順次読み込み
入力のメモリや条件に応じて
四則演算など命令を実行，変数を更新，別の命令へジャンプして，
出力のメモリを変化させていく．

これらは日本語で書いたが，すべての情報は01で書かれているので，読み込まれるのも書き出されるのも01の値である．

例えばp68にあるようなプログラムと対応する機械語があってそれが順次実行されていくにしたがって，メモリ，A,Dが変化していくこと，を理解できるようにする．






